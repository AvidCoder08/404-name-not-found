# Fraud Buster

**Live Demo:** [https://404namenotfound.vercel.app/](https://404namenotfound.vercel.app/)

## Tech Stack
* **Frontend:** React (Vite), Material-UI (`@mui/material`), Framer Motion, Emotion, `react-force-graph-2d` for network tracking
* **Backend:** FastAPI, Uvicorn, Python 3.9+
* **Data Processing & ML:** PyTorch (GraphSAGE), NetworkX, Pandas, Scikit-learn
* **Dashboard:** Streamlit & `streamlit-agraph` for local inference and visualization

## System Architecture
Fraud Buster uses a **Hybrid GNN Pipeline** (Score → Extract → Detect) designed to identify money muling and fraudulent transaction rings.
1. **Data Ingestion:** Transactions are fed into the system via the Streamlit UI or FastAPI backend.
2. **GNN Scoring:** A pre-trained Graph Neural Network (GNN) scores each account based on its transaction history and structural graph features.
3. **Subgraph Extraction:** High-risk nodes are extracted along with their n-hop neighborhood to form a localized, tractable subgraph.
4. **Pattern Detection:** Deterministic graph algorithms run exclusively on the suspicious subgraph to identify bounded cycles, shell networks, and temporal smurfing rings.
5. **Visualization:** Detected rings and risk scores are presented via an interactive graph UI.

## Algorithm Approach & Complexity Analysis
1. **Graph Neural Network (GNN) Scoring:**
   * **Approach:** A 3-layer GraphSAGE architecture maps node embeddings. It engineers and aggregates 14 specialized features (e.g., in/out degree, flow balance, fan-in/fan-out signals, neighbor diversity) to capture local topology.
   * **Complexity:** Message passing complexity is **O(|V| + |E|)**, scaling linearly with graph size, making it extremely fast for large-scale filtering.
2. **Pattern Detection (Deterministic Algorithms):** 
   * *Bounded Cycles (Length 3-5):* Conducts bounded Depth-First Search (DFS) to find circular money flows. Complexity is **O(|V| × d^k)** where *d* is average degree and *k=5*. It remains highly tractable because it runs solely on the GNN-filtered subgraph.
   * *Temporal Smurfs (Fan-in / Fan-out):* Detects 10+ transactions within a 72-hour window. Complexity is **O(|E| log |E|)** due to sorting operations on transaction timestamps.
   * *Layered Shells:* Identifies chains of 3+ hops where intermediate accounts exhibit balanced flow with low volume. Complexity is **O(|V| × d²)**.

## Suspicion Score Methodology
The **Suspicion Score** represents the probability (0-100%) that an account is involved in money laundering. This score is generated by training the GNN using a **Focal Loss** mechanism (with alpha=0.7, gamma=2.0) to aggressively handle class imbalance (since fraud is exceptionally rare in the overall dataset). 

By extracting multi-hop structural flow features—such as excessive incoming-to-outgoing ratio, transaction bursts, and tight reciprocal connections—the model computes raw suspicion probabilities. Nodes scoring above a specific confidence threshold (e.g., 50%) are conclusively flagged as high risk.

## Installation & Setup
1. **Clone the repository:**
   ```bash
   git clone <repo_url>
   cd 404-name-not-found
   ```

2. **Backend Setup (Python):**
   ```bash
   # Create and activate a Virtual Environment
   python -m venv .venv
   # On Windows:
   .venv\Scripts\activate
   # On macOS/Linux:
   source .venv/bin/activate

   # Install Dependencies
   pip install -r requirements.txt
   ```

3. **Frontend Setup (Node.js):**
   ```bash
   cd frontend
   npm install
   ```

## Usage Instructions

### 1. Running the Services

**Option A: Streamlit Dashboard (Recommended for Data Exploration)**
Provides a comprehensive single-page UI to train models, tweak hyperparameters, and visualize graph structures natively.
1. Ensure your Python virtual environment is activated.
2. Run the dashboard from the project root:
   ```bash
   streamlit run app.py
   ```
3. Open `http://localhost:8501` in your browser.

**Option B: Full Web Application (React + FastAPI)**
Run the independent React frontend application powered by the high-performance FastAPI back-end API.
1. Start the FastAPI server from the root directory:
   ```bash
   uvicorn backend.main:app --reload
   ```
2. Start the React development server in a new terminal:
   ```bash
   cd frontend
   npm run dev
   ```
3. Open the localhost URL displayed in the terminal (usually `http://localhost:5173`).

### 2. Operating the Detection Engine

1. **Train the Model (One-Time Setup):**
   * Open the Streamlit application.
   * On the sidebar under **Data Input**, upload your labeled training CSV (or rely on default `.csv` datasets available in `data/`).
   * In the **Detection Dashboard** tab, click **Train & Save GNN Model**. The engine extracts 14 multi-hop node features, trains a PyTorch GraphSAGE model, and caches the weights locally.
2. **Analyze Live/Test Data:**
   * Upload an unclassified test dataset (with columns: `transaction_id, sender_id, receiver_id, amount, timestamp`).
   * Tweak the **GNN Suspicion Threshold** (to configure sensitivity) and **Subgraph Neighborhood** sliders.
   * Click **Analyze Dataset** to batch-process risk scores and execute deterministic pattern detection.
3. **Explore Validation Results:**
   * **Detection Dashboard:** Review high-risk accounts and detailed breakdowns of extracted structural fraud rings (Bounded Cycles, Temporal Smurfs, Layered Shells).
   * **Graph Visualization:** Interactively explore the 2D network schema. Entities are color-coded based on raw GNN suspicion probabilities.
   * **Export Results:** Dump all inference logs and flagged account IDs into JSON/CSV files for integrations with external compliance engines.

## Known Limitations
* **Bounded Compute:** Cycle detection is strictly limited to a length of 5 hops maximum to maintain real-time responsiveness.
* **Temporal Dependency:** Smurfing detection relies wholly on accurate timestamp granularity; missing or malformed timestamps reduce detection efficacy.
* **Hardware Profile:** PyTorch is currently configured for CPU-only inference (tailored for Render cloud deployments), meaning that retraining on extremely massive datasets may be slower without GPU toggles.

## Team Members
* **Shivani Shankar**
* **Shreyansh Tandon**
* **Soham Shashank Reddy Munnangi**
